/*. Add the option -f to fold upper and lower case together, so that case 
distinctions are not made during sorting; for example, a and A compare equal.  */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAXLINES 5000
#define MAXLEN   1000

char *lineptr[MAXLINES];

int numeric = 0;
int reverse = 0;
int fold = 0;

int getline_custom(char *s, int lim) {
    int c, i = 0;
    while (--lim > 0 && (c = getchar()) != EOF && c != '\n')
        s[i++] = c;
    if (c == '\n')
        s[i++] = c;
    s[i] = '\0';
    return i;
}

int readlines(char *lineptr[], int maxlines) {
    int len, nlines = 0;
    char *p, line[MAXLEN];

    while ((len = getline_custom(line, MAXLEN)) > 0) {
        if (nlines >= maxlines || (p = malloc(len + 1)) == NULL)
            return -1;
        strcpy(p, line);
        lineptr[nlines++] = p;
    }
    return nlines;
}

void writelines(char *lineptr[], int nlines) {
    for (int i = 0; i < nlines; i++)
        printf("%s", lineptr[i]);
}

int numcmp(const char *s1, const char *s2) {
    double v1 = atof(s1);
    double v2 = atof(s2);
    if (v1 < v2) return -1;
    else if (v1 > v2) return 1;
    else return 0;
}

int strfcmp(const char *s1, const char *s2) {
    while (*s1 && *s2) {
        int c1 = tolower((unsigned char)*s1);
        int c2 = tolower((unsigned char)*s2);
        if (c1 != c2) return c1 - c2;
        s1++;
        s2++;
    }
    return tolower((unsigned char)*s1) - tolower((unsigned char)*s2);
}

int cmp_wrapper(const void *a, const void *b) {
    const char *s1 = *(const char **)a;
    const char *s2 = *(const char **)b;
    int result;

    if (numeric)
        result = numcmp(s1, s2);
    else if (fold)
        result = strfcmp(s1, s2);
    else
        result = strcmp(s1, s2);

    if (reverse)
        return -result;
    return result;
}

int main(int argc, char *argv[]) {
    int nlines;

    for (int i = 1; i < argc; i++) {
        if (argv[i][0] == '-') {
            for (int j = 1; argv[i][j] != '\0'; j++) {
                if (argv[i][j] == 'n')
                    numeric = 1;
                else if (argv[i][j] == 'r')
                    reverse = 1;
                else if (argv[i][j] == 'f')
                    fold = 1;
            }
        }
    }

    if (numeric)
        fold = 0;

    if ((nlines = readlines(lineptr, MAXLINES)) < 0)
        return 1;

    qsort(lineptr, nlines, sizeof(char *), cmp_wrapper);

    writelines(lineptr, nlines);

    for (int i = 0; i < nlines; i++)
        free(lineptr[i]);

    return 0;
}
/*output
subiksha@DESKTOP-CBQDRR5:~$ ./ex5-15
Banana
apple
Cherry
10
2


10
2
Banana
Cherry
apple
subiksha@DESKTOP-CBQDRR5:~$ ./ex5-15 -f
Banana
apple
Cherry
10
2


10
2
apple
Banana
Cherry
subiksha@DESKTOP-CBQDRR5:~$ ./ex5-15 -n
Banana
apple
Cherry
10
2

Banana
apple
Cherry

2
10
subiksha@DESKTOP-CBQDRR5:~$ ./ex5-15 -nr
Banana
apple
Cherry
10
2

10
2
Banana
apple
Cherry

*/